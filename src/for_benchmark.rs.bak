use crate::fast_repair::{self, SortOrder};
use crate::fusion;
use crate::optimize_slp::*;
use crate::reorder::{self, Pebble, Strategy};
use crate::reorder2;
use crate::repair;
use crate::slp::SLP;
use crate::validation;
use crate::xor_repair;
use crate::Term;
use crate::*;

#[derive(Debug, Clone, Copy)]
pub enum XorDirection {
    None,
    Forward,
    Backward,
}

pub fn naiive(original_slp: &SLP) -> Vec<(Pebble, Vec<Pebble>)> {
    let (shrinked_slp, _) = step1(original_slp);
    let shrinked_program = shrinked_slp.to_trivial_graph();
    let program = graph_to_multiterm_slp(&shrinked_program);

    reorder::term_slp_to_pebble_slp(&program)
}

fn rename(valuation: &Valuation, program: &[(Pebble, Vec<Pebble>)]) -> Vec<(Pebble, Vec<Pebble>)> {
    let mapping = validation::is_subvaluation(
        &valuation,
        &validation::pebble_computation_to_valuation(program),
    );

    let mapping: Vec<(usize, usize)> = mapping
        .unwrap()
        .iter()
        .map(|(a, b)| (a.var_to_usize().unwrap(), b.var_to_usize().unwrap()))
        .collect();

    let renaming = renaming::mapping_to_rewriting(&mapping);
    let renamed =
        renaming::rename_multislp_by(&renaming, &reorder::pebble_slp_to_term_slp(program));

    assert!(validation::is_strict_subvaluation(
        &valuation,
        &validation::term_computation_to_valuation(&renamed)
    ));

    reorder::term_slp_to_pebble_slp(&renamed)
}

pub fn ssa(original_slp: &SLP) -> Vec<(Pebble, Vec<Pebble>)> {
    let (shrinked_slp, _) = step1(original_slp);
    let shrinked_program = shrinked_slp.to_trivial_graph();
    let shrinked_valuation = validation::slp_to_valuation(&shrinked_slp);

    let ssa = fusion::slp_to_ssa(&shrinked_program);
    let ssa = graph_to_multiterm_slp(&ssa);

    let mapping = validation::is_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&ssa),
    );
    assert!(mapping.is_some());
    let mapping: Vec<(usize, usize)> = mapping
        .unwrap()
        .iter()
        .map(|(a, b)| (a.var_to_usize().unwrap(), b.var_to_usize().unwrap()))
        .collect();
    let renaming = renaming::mapping_to_rewriting(&mapping);

    let renamed = renaming::rename_multislp_by(&renaming, &ssa);
    assert!(validation::is_strict_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    ));
    reorder::term_slp_to_pebble_slp(&renamed)
}

pub fn ssa_fusion(original_slp: &SLP) -> Vec<(Pebble, Vec<Pebble>)> {
    let (shrinked_slp, _) = step1(original_slp);
    let shrinked_program = shrinked_slp.to_trivial_graph();
    let shrinked_valuation = validation::slp_to_valuation(&shrinked_slp);

    let ssa = fusion::slp_to_ssa(&shrinked_program);

    let evaluated = repair::evaluate_program(&ssa);
    let targets: Vec<Term> = {
        let mapping = repair::realizes(&evaluated, &shrinked_slp).unwrap();
        mapping.iter().map(|(a, _)| Term::Var(*a)).collect()
    };

    let multislp = fusion::graph_to_multislp_by_fusion(ssa, &targets);
    let mapping = validation::is_subvaluation(
        &shrinked_valuation,
        &validation::multislp_to_valuation(&multislp),
    );
    assert!(mapping.is_some());
    let mapping: Vec<(usize, usize)> = mapping
        .unwrap()
        .iter()
        .map(|(a, b)| (a.var_to_usize().unwrap(), b.var_to_usize().unwrap()))
        .collect();
    let renaming = renaming::mapping_to_rewriting(&mapping);

    let renamed = renaming::rename_multislp_by(&renaming, &multislp_to_multiterm_slp(&multislp));
    assert!(validation::is_strict_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    ));
    reorder::term_slp_to_pebble_slp(&renamed)
}

pub fn ssa_reorder(original_slp: &SLP) -> Vec<(Pebble, Vec<Pebble>)> {
    let (shrinked_slp, _) = step1(original_slp);
    let shrinked_program = shrinked_slp.to_trivial_graph();
    let shrinked_valuation = validation::slp_to_valuation(&shrinked_slp);

    let ssa = fusion::slp_to_ssa(&shrinked_program);

    let evaluated = repair::evaluate_program(&ssa);
    let targets: Vec<Term> = {
        let mapping = repair::realizes(&evaluated, &shrinked_slp).unwrap();
        mapping.iter().map(|(a, _)| Term::Var(*a)).collect()
    };

    let multislp = fusion::graph_to_multislp_by_fusion(ssa, &targets);
    let mapping = validation::is_subvaluation(
        &shrinked_valuation,
        &validation::multislp_to_valuation(&multislp),
    );
    assert!(mapping.is_some());

    let scheduled = reorder2::deal_multislp2(&multislp, 80, targets, Strategy::UseMRU);

    let mapping = validation::is_subvaluation(
        &shrinked_valuation,
        &validation::pebble_computation_to_valuation(&scheduled),
    );

    assert!(mapping.is_some());
    let mapping: Vec<(usize, usize)> = mapping
        .unwrap()
        .iter()
        .map(|(a, b)| (a.var_to_usize().unwrap(), b.var_to_usize().unwrap()))
        .collect();

    let renaming = renaming::mapping_to_rewriting(&mapping);
    let renamed =
        renaming::rename_multislp_by(&renaming, &reorder::pebble_slp_to_term_slp(&scheduled));
    assert!(validation::is_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    )
    .is_some());

    assert!(validation::is_strict_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    ));

    reorder::term_slp_to_pebble_slp(&renamed)
}

pub fn compress(
    original_slp: &SLP,
    direction: XorDirection,
    order: SortOrder,
) -> Vec<(Pebble, Vec<Pebble>)> {
    let (shrinked_slp, _) = step1(original_slp);
    let shrinked_valuation = validation::slp_to_valuation(&shrinked_slp);

    let repaired = match direction {
        XorDirection::None => fast_repair::run_repair2(&shrinked_slp, order),
        XorDirection::Forward => xor_repair::run_xor_repair_forward(&shrinked_slp, order),
        XorDirection::Backward => xor_repair::run_xor_repair_forward(&shrinked_slp, order),
    };

    let evaluated = repair::evaluate_program(&repaired);
    let mapping = repair::realizes(&evaluated, &shrinked_slp).unwrap();
    let renaming = renaming::mapping_to_rewriting(&mapping);

    let renamed = renaming::rename_multislp_by(&renaming, &graph_to_multiterm_slp(&repaired));
    assert!(validation::is_strict_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    ));
    reorder::term_slp_to_pebble_slp(&renamed)
}

pub fn fusion(
    original_slp: &SLP,
    direction: XorDirection,
    order: SortOrder,
) -> Vec<(Pebble, Vec<Pebble>)> {
    let (shrinked_slp, _) = step1(original_slp);
    let shrinked_valuation = validation::slp_to_valuation(&shrinked_slp);

    let repaired = match direction {
        XorDirection::None => fast_repair::run_repair2(&shrinked_slp, order),
        XorDirection::Forward => xor_repair::run_xor_repair_forward(&shrinked_slp, order),
        XorDirection::Backward => xor_repair::run_xor_repair_forward(&shrinked_slp, order),
    };

    let evaluated = repair::evaluate_program(&repaired);
    let targets: Vec<Term> = {
        let mapping = repair::realizes(&evaluated, &shrinked_slp).unwrap();
        mapping.iter().map(|(a, _)| Term::Var(*a)).collect()
    };
    let multislp = fusion::graph_to_multislp_by_fusion(repaired, &targets);

    let mapping = validation::is_subvaluation(
        &shrinked_valuation,
        &validation::multislp_to_valuation(&multislp),
    );
    assert!(mapping.is_some());
    let mapping: Vec<(usize, usize)> = mapping
        .unwrap()
        .iter()
        .map(|(a, b)| (a.var_to_usize().unwrap(), b.var_to_usize().unwrap()))
        .collect();
    let renaming = renaming::mapping_to_rewriting(&mapping);

    let renamed = renaming::rename_multislp_by(&renaming, &multislp_to_multiterm_slp(&multislp));
    assert!(validation::is_strict_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    ));
    reorder::term_slp_to_pebble_slp(&renamed)
}

pub fn do_xor3(
    original_slp: &SLP,
    direction: XorDirection,
    order: SortOrder,
) -> Vec<(Pebble, Vec<Pebble>)> {
    let (shrinked_slp, _) = step1(original_slp);
    let shrinked_valuation = validation::slp_to_valuation(&shrinked_slp);

    let defs_xor_repair = match direction {
        XorDirection::None => fast_repair::run_repair2(&shrinked_slp, order),
        XorDirection::Forward => xor_repair::run_xor_repair_forward(&shrinked_slp, order),
        XorDirection::Backward => xor_repair::run_xor_repair_forward(&shrinked_slp, order),
    };
    let evaluated = repair::evaluate_program(&defs_xor_repair);

    let mapping = repair::realizes(&evaluated, &shrinked_slp).unwrap();
    let targets: Vec<Term> = mapping.iter().map(|(a, _)| Term::Var(*a)).collect();

    let multislp = fusion::graph_to_multislp_by_fusion(defs_xor_repair, &targets);

    assert!(validation::is_subvaluation(
        &shrinked_valuation,
        &validation::multislp_to_valuation(&multislp)
    )
    .is_some());

    let scheduled = reorder::deal_multislp(&multislp, 80, targets, Strategy::UseMRU);

    let mapping = validation::is_subvaluation(
        &shrinked_valuation,
        &validation::pebble_computation_to_valuation(&scheduled),
    );

    assert!(mapping.is_some());
    let mapping: Vec<(usize, usize)> = mapping
        .unwrap()
        .iter()
        .map(|(a, b)| (a.var_to_usize().unwrap(), b.var_to_usize().unwrap()))
        .collect();

    let renaming = renaming::mapping_to_rewriting(&mapping);
    let renamed =
        renaming::rename_multislp_by(&renaming, &reorder::pebble_slp_to_term_slp(&scheduled));
    assert!(validation::is_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    )
    .is_some());

    assert!(validation::is_strict_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    ));

    reorder::term_slp_to_pebble_slp(&renamed)
}

pub fn do_xor4(
    original_slp: &SLP,
    direction: XorDirection,
    order: SortOrder,
) -> Vec<(Pebble, Vec<Pebble>)> {
    let (shrinked_slp, _) = step1(original_slp);
    let shrinked_valuation = validation::slp_to_valuation(&shrinked_slp);

    let defs_xor_repair = match direction {
        XorDirection::None => fast_repair::run_repair2(&shrinked_slp, order),
        XorDirection::Forward => xor_repair::run_xor_repair_forward(&shrinked_slp, order),
        XorDirection::Backward => xor_repair::run_xor_repair_backward(&shrinked_slp, order),
    };
    let evaluated = repair::evaluate_program(&defs_xor_repair);

    let mapping = repair::realizes(&evaluated, &shrinked_slp).unwrap();
    let targets: Vec<Term> = mapping.iter().map(|(a, _)| Term::Var(*a)).collect();

    let multislp = fusion::graph_to_multislp_by_fusion(defs_xor_repair, &targets);

    assert!(validation::is_subvaluation(
        &shrinked_valuation,
        &validation::multislp_to_valuation(&multislp)
    )
    .is_some());

    let scheduled = reorder2::deal_multislp2(&multislp, 80, targets, Strategy::UseMRU);

    let mapping = validation::is_subvaluation(
        &shrinked_valuation,
        &validation::pebble_computation_to_valuation(&scheduled),
    );

    assert!(mapping.is_some());
    let mapping: Vec<(usize, usize)> = mapping
        .unwrap()
        .iter()
        .map(|(a, b)| (a.var_to_usize().unwrap(), b.var_to_usize().unwrap()))
        .collect();

    let renaming = renaming::mapping_to_rewriting(&mapping);
    let renamed =
        renaming::rename_multislp_by(&renaming, &reorder::pebble_slp_to_term_slp(&scheduled));
    assert!(validation::is_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    )
    .is_some());

    assert!(validation::is_strict_subvaluation(
        &shrinked_valuation,
        &validation::term_computation_to_valuation(&renamed)
    ));

    reorder::term_slp_to_pebble_slp(&renamed)
}
